package net.doubledoordev.mtrm;

import com.google.common.io.Files;
import net.doubledoordev.mtrm.xml.XmlParser;
import net.minecraft.item.ItemStack;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.common.Loader;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author Dries007
 */
@SuppressWarnings("WeakerAccess")
public final class Helper
{
    public static final String MODID = "MTRM";
    public static final String NAME = "MineTweakerRecipeMaker";
    public static final DateFormat DATE_TIME = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");

    public static final String DTD = "/assets/mtrm/MTRM.dtd";

    private Helper() {}

    public static File getScriptFile() throws IOException
    {
        File file = new File("scripts/MineTweakerRecipeMaker/scripts/", "MTRM.zs");
        Files.createParentDirs(file);
        if (!file.exists())
        {
            Files.touch(file);
            writeHeader(Files.newWriter(file, Charset.defaultCharset()), "<SERVER>").close();
        }
        return file;
    }

    public static BufferedWriter writeHeader(BufferedWriter br, String name) throws IOException
    {
        br.write("// File generated by MineTweakerRecipeMaker (MTRM) by DoubleDoorDevelopment\r\n");
        br.write("// This file is automatically managed by MTRM.\r\n");
        br.write("// Try not to touch it if you don't absolutely have to.\r\n");
        br.write("// If you have too, leave the markers alone. They look like this:\r\n");
        br.write("//\r\n");
        br.write("//    #MTRM MARKER <number here>\r\n");
        br.write("//\r\n");
        br.write("// ================================================================================\r\n");
        br.write("print(\"Loading the MineTweakerRecipeMaker (MTRM) script file.\");");
        br.write("// HERE BE DRAGONS\r\n\r\n");
        return br;
    }

    /**
     * Recursive XML file finder. Always returns the given list.
     * @return the list parameter
     */
    public static List<File> findXMLFiles(File folder, List<File> list)
    {
        for (File file : folder.listFiles(new FileFilter() {
            @Override
            public boolean accept(File pathname)
            {
                return pathname.isDirectory() || FilenameUtils.getExtension(pathname.getName()).equalsIgnoreCase("XML");
            }
        }))
        {
            if (file.isDirectory()) findXMLFiles(file, list);
            else list.add(file);
        }
        return list;
    }

    public static void makeReadme(File file) throws IOException
    {
        FileUtils.writeLines(file, Arrays.asList(
            "If you want to manually add or edit XML config files, put them in there like they would be in a resourcepack.",
            "This WILL override existing files if they already exist. There will be no version checking!",
            "If you make a useful change, submit it to the original authors, so everyone will benefit.",
            "~Dries007",
            "",
            "EXAMPLES:",
            "You want the edit the default vanilla XML: Put it at 'overrides/mtrm/vanilla.xml'",
            "If you want to add a new XML file, you can put it wherever inside of 'overrides', as long as it has a sub-folder.",
            "",
            "The current MTRM DTD File: (Use this to make sure your XML is correct):",
            ""
        ), "\r\n");
        InputStream is = MineTweakerRecipeMaker.class.getResourceAsStream(DTD);
        FileUtils.writeStringToFile(file, IOUtils.toString(is).replaceAll("\\r?\\n", "\n"), true);
        is.close();
    }

    public static ResourceLocation normalize(ResourceLocation location)
    {
        String path = location.getResourcePath();
        if (path.startsWith("assets/")) path = path.substring(path.indexOf('/'));
        if (path.endsWith(".xml") || path.endsWith(".XML")) path = path.substring(0, path.lastIndexOf('.'));
        return new ResourceLocation(location.getResourceDomain(), path);
    }

    public static void loadOverrides(List<File> skip) throws Exception
    {
        File modFolder = new File(Loader.instance().getConfigDir(), Helper.MODID);
        if (!modFolder.exists()) modFolder.mkdirs();
        Helper.makeReadme(new File(modFolder, "README.txt"));
        File rootFolder = new File(modFolder, "overrides");
        if (!rootFolder.exists()) rootFolder.mkdirs();
        Path root = rootFolder.toPath();
        List<File> list = Helper.findXMLFiles(rootFolder, new ArrayList<File>());
        list.removeAll(skip);
        for (File f : list)
        {
            String path = root.relativize(f.toPath()).toString().replaceFirst("\\\\|/", ":");
            XmlParser.addOverrideXml(new ResourceLocation(path), f);
        }
    }

    public static String truncate(String text, int width)
    {
        return text.length() < width ? text : text.substring(0, width) + "...";
    }

    public static String itemstackToString(ItemStack stack)
    {
        if (stack == null) return "null";
        StringBuilder sb = new StringBuilder("<");
        sb.append(stack.getItem().getRegistryName());
        int meta = stack.getMetadata();
        if (meta != 0) sb.append(meta);
        sb.append('>');
        if (stack.stackSize != 1) sb.append('*').append(stack.stackSize);
        return sb.toString();
    }

    public static double round(double in, double precision)
    {
        return precision * Math.floor(in / precision);
    }
}
